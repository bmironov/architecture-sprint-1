# Спринт 1
## Содержимое
- [Введение](#Введение)
- [Задание 1](#Задание-1)
- [Задание 2](#Задание-2)

## Введение

Должен заметить, что записался я на этот курс для упорядочивания и обновления
своих знаний в этой области накопленных за годы работы в IT в роли Oracle DBA
с прямым включением в команды разработки. При этом я пробовал все технологии,
которые использовались командами как для разработки самих приложений, так и для
функционирования этих приложений с точки зрения back end management. Поэтому
удалось "потрогать руками" и Ruby on Rails, и Django, jQuery, Bootstrap (CSS),
Java, Go, C++, PostgreSQL, MySQL и многое другое.

Я не занимался разработкой на JavaScript полноценных приложений, потому что на
том эnапе у меня сложилось довольно низкое мнение об этом языке по сравнению
с такими языками как C++, Java, PL/SQL. В ходе этого курса, постараюсь обновить
свои знания в области NPM и полноценной JavaScript разработки.

Вчера в Пачке было обсуждение про Single SPA против Webpack Module Federation,
где было сказано, что в общем-то они примерно одинаковы, но в курсе говорится
о том, что Single SPA изначально позволяет сосуществовать различным фреймворкам
в пределах одного общего приложения. Таким образом появляется большая гибкость
в миграции монолита. В добавок к этому, Webpack Module Federation уже был
продемонстрирован в первой лабораторной работе.

## Задание 1

Деление монолита Mesto будем производить по Domain Driven Design. Приложение у
нас на текущем этапе очеь простое, поэтому нет смысла тратить время на
Технический Анализ. Объединять новые микрофронтенды будем с помощью Single SPA,
как более гибким методом по сравнению с Webpack Module Federation. В перспективе
это позволит заменить текущий React на какой-нибудь другой.

У монолитного приложения всего две сущности (по их описанию в
[моделях бэкенда](https://github.com/bmironov/architecture-sprint-1/tree/main/backend/src/models)):
- `card`
- `user`

Весь их функционал легко сводится в одну таблицу БД на каждую из сущностей с
примерно следующими структурами:
```
interface ICard {
  name: string;
  link: string;
  owner: ObjectId;
  likes: ObjectId[];
  createdAt: Date | string;
}

interface IUser extends Document {
  name: string;
  about: string;
  avatar: string;
  email: string;
  password: string;
}
```

В живой БД на начальном этапе к этим полям будут добавлены и другие. Например,
в случае реляционных БД это будут и primary keys, и constrains, и NOT NULL для
поддержания целостности данных.

В итоге у нас получится 2 приложения, которые будут обслуживать эти сущности.
На данном этапе произведем простое разделение монолитного кода на два отдельных
приложения. А в перспективе Single SPA позволит перейти с React на какие-нибудь
другие библиотеки, если возникнет необходимость (например, Angular для `user`)

Так как приложение называется "Mesto", то название сущности `card` не совсем
верно отображает название сущности, поэтому используем эту возможность
(разделение монолита) для правильного именования - `place`, а его микрофронтед
назовем `places` (во множественном числе, так же как и `users`).

В монолите есть компоненты, которые используются как для `user`, так и для
`card`. Примером может послужить `PopupWithForm`. Его невозможно вынести в
связующее приложение `host` и потом импортировать в `users` и `places`. Пожжтому
для подобный "общих" элементов создадим отдельное приложение `library`.

Примерная структура новых приложений (с именами компонентов исходного приложения
Mesto) приведена ниже. Еси указан подкаталог без расшифровки конкретных файлов,
то переносится все его содержимое из монолита (например, `images`,
`vendor/fonts`). Все описанные ниже компоненты переносятся только из подкаталога
`frontend` монолита. Чтобы подчеркнуть, что это подкаталоги и все файлы в них,
после такого имени добавляется `/*`.

```
host
    src
        blocks
        components
            App.js
            Footer.js
            Header.js
            Main.js
        utils
            api.js
        index.css
        index.js

library
    src
        blocks
            card/*
            content/*
            footer/*
            header/*
            page/*
            popup/*
        components
            PopupWithForm.js
            ProtectedRoute.js
        contexts
            CurrentUserContext.js
        images/*
        public/*
        vendor
            fonts/*
            fonts.css
            normalize.css
        logo.svg
        serviceWorker.js

users
    src
        blocks
            auth-form/*
            login/*
            profile/*
        components
            EditAvatarPopup.js
            EditProfilePopup.js
            InfoTooltip.js
            Login.js
            Register.js
        utils
            auth.js

places
    src
        blocks
            places/*
        components
            AddPlacePopup.js
            Card.js
            ImagePopup.js
```

Это примерное распределение составных частей монолита между новыми приложениями
"с высоты птичьего полета". Не всегда файлы будут копироваться один-в-один.
Структура скорее отображает как функционал монолита будет разделен на части.

Таким образом, в итоге приложение `host` будет заниматься "склеиванием" трех
других: `library`, `users` и `places`.
Микросервис `users` будет заниматься аутентификацией и авторизацией
пользователей, их регистрацией и поддержанием их профилей.
Микросервис `places` будет отвечать за созание новых "мест", отрисовку карточек
этих мест, обработку лайков

## Задание 2

Это задание выполнено в мультистраничной диаграмме **draw.io**.

Из-за нехватки времени на выверение диаграммы, в ней возможны опечатки и
неточности. Кое-какие моменты требуют более тщательной проработки. Например,
сервис уведомлений должен поддерживать функционал обработки ошибки отправки
сообщений и уведомлять сервис-отправитель какими-то специализированными
сообщениями. Далее, сервис, заказавший эту отправку должен предпринимать
какие-то действия.

Диаграмма монолитной системы достаточно неполная и многие функции приходится
либо добавлять (подозревая, что они упущены), либо помещать в некорректные
сервисы новой системы из-за неоднозначности понимания настоящего их функционала.
В связи с этим, перед началом обсуждения диаграммы новой системы необходимо
ознакомится с этой системой чтобы хотя бы наглядно понять о чем идет речь на
исходной диаграмме Django-системы.

Так как задание заключается в разбиении монолита на микросервисы, то на
диаграмме все стрелки взаимодействий должны быть красными. Исключением тут
является взаимодействие с внешними системами платежей. Там все стрелки -
черные. Для упрощения понимания межсервисных взаимодействий на общей диаграмме
использованы различные цвета в зависимости от серсвиса, инициирующего диалог.
Стрелка показывает направление начала такого диалога.

Эндпойнты обозначены кружочками. Эти кружочки находятся с обеих сторон
конкретного обмена (сообщения) между сервисами. Это сделано для получения
большей гибкости, чем draw.io может представить у своих элементов (3 на каждую
из 4-х сторон элемента). В случае когда между сервисами происходит обмен более
чем парой сообщений, такие "кружочки" превращаются в прямоугольники с диапазоном
или списком сообщений и стрелка становится двусторонней. При намерации сообщений
используются цифры и буквы. Некоторые буквы пропускаются из-за совпадения по
начертанию с цифрами.

Это довольно сложная система, поэтому рекомендуется сразу начать со слоем
Backend for Frontend. Вид активности этой системы не подразумевает критичность
к небольшим задержкам из-за этого слоя, но позволит сразу же изолировать
фронтэнд от сервисов. Это сразу же упростит код микрофронтендов. Базироваться
они должны на Single SPA для закладывания большей независимости между ними по
фреймворкам в первспективе.

Ссылка на [диаграмму решения задания №2](https://raw.githubusercontent.com/bmironov/architecture-sprint-1/refs/heads/sprint_1/Sprint_01_task_02_solution.drawio).

PS Если по какой-то причине эта ссылка не открывается, диаграмма приложена к
Pull Request и находится в корневом подкаталоге проекта в файле
`Sprint_01_task_02_solution.drawio`